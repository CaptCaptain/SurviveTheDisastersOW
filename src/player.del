import "main.ostw";

single struct ScoreboardListing {
    public Player Player;
    public Color HeaderColor;
    public Number TextId;
    public Number Score;
    public Number Streak;
    public Number Achievements;
}

class Scoreboard {
    public static ScoreboardListing[] List = [];
    
    public static void CreateListing(in Player Player) {        
        String Whitespace: "                                                                                                                                                                ";

        CreateHudText(
            VisibleTo: AllPlayers(),
            Header: "{0}".Format([HeroIconString(HeroOf(Player))]),
            Text: EvaluateOnce("{0}".Format([Player]) + Whitespace),
            Subheader: "Score: {0} | Streak: {1} | Achievements: {2}".Format([
                List[EvaluateOnce(SlotOf(Player))].Score,
                List[EvaluateOnce(SlotOf(Player))].Streak,
                List[EvaluateOnce(SlotOf(Player))].Achievements
            ]),
            SortOrder: 0,
            HeaderColor: List[EvaluateOnce(SlotOf(Player))].HeaderColor,
            SubheaderColor: EvaluateOnce(Color.Orange),
            Reevaluation: HudTextRev.VisibleToStringAndColor
        );

        List[SlotOf(Player)] = {
            Player: Player,
            HeaderColor: Color.White,
            TextId: LastTextID(),
            Score: 0,
            Streak: 0,
            Achievements: 0
        };
    }

    public static Boolean PlayerStateColor(ScoreboardListing Listing): HasSpawned(Listing.Player) ? IsAlive(Listing.Player) ? ArrayContains(GameHandler.DeadPlayers, Listing.Player) ? Color.Orange : Color.LimeGreen : Color.Red : Color.White;

    public static void StartUpdatingPlayerState() {
        Boolean PlayersChanged: AllPlayers(Team.Team1) != EvaluateOnce(AllPlayers(Team.Team1));
        Boolean LivingPlayersChanged: AllLivingPlayers(Team.Team1) != EvaluateOnce(AllLivingPlayers(Team.Team1));
        Boolean DeadPlayersChanged: AllDeadPlayers(Team.Team1) != EvaluateOnce(AllDeadPlayers(Team.Team1));

        WaitUntil(PlayersChanged || LivingPlayersChanged || DeadPlayersChanged, 2);

        List = <ScoreboardListing[]>MappedArray(List, <ScoreboardListing>{
            Player: (<ScoreboardListing>ArrayElement()).Player,
            HeaderColor: PlayerStateColor(<ScoreboardListing>ArrayElement()),
            TextId: (<ScoreboardListing>ArrayElement()).TextId
        });

        Loop();
    }
}

class ObjectiveHud {
    public static String ObjectiveString = "Waiting for Players";

    public static void SetObjectiveText(String Text) {
        ObjectiveString = Text;
    }
    
    public static void CreateHUD() {
        CreateHudText(
            VisibleTo: AllPlayers(),
            Header: "",
            Subheader: "",
            Text: ObjectiveString,
            Location: Location.Top,
            SortOrder: -1,
            HeaderColor: Color.White,
            SubheaderColor: Color.White,
            TextColor: Color.White,
            Reevaluation: HudTextRev.VisibleToAndString,
            Spectators: Spectators.DefaultVisibility
        );
        
        CreateHudText(
            VisibleTo: AllPlayers(),
            Header: "",
            Subheader: " ",
            Text: "",
            Location: Location.Top,
            SortOrder: 0,
            HeaderColor: Color.White,
            SubheaderColor: Color.White,
            TextColor: Color.White,
            Reevaluation: HudTextRev.VisibleToAndString,
            Spectators: Spectators.DefaultVisibility
        );
    }
}

class TimerHud {
    public static Number GetMinutes(Number Seconds): RoundToInteger(Seconds / 60, Rounding.Down);
    public static String GetMinutesString(Number Minutes): (GetMinutes(Minutes) < 10 ? "0%s" : "%s").Replace("%s", <String>"{0}".Format([GetMinutes(Minutes)]));
    public static Number GetSeconds(Number Seconds): RoundToInteger(Seconds % 60, Rounding.Down);
    public static String GetSecondsString(Number Seconds): (GetSeconds(Seconds) < 10 ? "0%s" : "%s").Replace("%s", <String>"{0}".Format([GetSeconds(Seconds)]));

    public static String GetTimerString(): "{0}:{1}".Format([GetMinutesString(MatchTime()), GetSecondsString(MatchTime())]);
    public static String CurrentTimerString;

    public static Color DefaultTimerColor: Color.White;
    public static Color EndingTimerColor: CustomColor(179, 19, 18, 255);
    public static Color NoTimerColor: CustomColor(255, 255, 255, 0);

    public static Color TimerColor = Color.White;

    public static void main() {
        WaitUntil(RoundToInteger(MatchTime()) != EvaluateOnce(RoundToInteger(MatchTime())), 1);

        if (MatchTime() == 0) {
            TimerColor = NoTimerColor;
        } else if (MatchTime() <= 11) {
            TimerColor = EndingTimerColor;
        } else {
            TimerColor = DefaultTimerColor;
        }

        CurrentTimerString = GetTimerString();

        Wait(0.016);

        Loop();
    }

    public static void CreateHUD() {
        CreateHudText(
            VisibleTo: AllPlayers(),
            Header: CurrentTimerString,
            Subheader: EvaluateOnce(""),
            Text: EvaluateOnce(""),
            Location: Location.Top,
            SortOrder: 1,
            HeaderColor: TimerColor,
            SubheaderColor: EvaluateOnce(Color.White),
            TextColor: EvaluateOnce(Color.White),
            Reevaluation: HudTextRev.VisibleToStringAndColor,
            Spectators: Spectators.DefaultVisibility
        );
    }
}

# - Limits the maximum health of a player
# - Intended to be used in player rules only
void SetLimitedMaxHealth() "Set Limited Max Health" {
    Number ScaledHealthPercentage: (MaxHealthLimit / MaxHealth(EventPlayer()));
    Number ScaledHealth: RoundToInteger(MaxHealthOfType(EventPlayer(), HealthType.Health) * ScaledHealthPercentage, Rounding.Nearest);
    Number ScaledArmor: RoundToInteger(MaxHealthOfType(EventPlayer(), HealthType.Armor) * ScaledHealthPercentage, Rounding.Nearest);
    Number ScaledShields: RoundToInteger(MaxHealthOfType(EventPlayer(), HealthType.Shields) * ScaledHealthPercentage, Rounding.Nearest);

    CustomHealthHandler.SendCustomHealthRequest(EventPlayer(), ScaledHealth, ScaledShields, ScaledArmor);
}

Number MaxHealthLimit: 350;
Boolean HeroChanged: EventPlayer().Hero() != EvaluateOnce(EventPlayer().Hero());
Boolean IsDva: EventPlayer().Hero() == Hero.Dva;
Boolean ChangedForm: (IsInAlternateForm(EventPlayer()) != EvaluateOnce(IsInAlternateForm(EventPlayer())));
Boolean ChangedHealth: (MaxHealthOfType(EventPlayer(), HealthType.Health) != EvaluateOnce(MaxHealthOfType(EventPlayer(), HealthType.Health)));
rule: 'Player Setup' Event.OngoingPlayer Team.Team1
{
    WaitUntil(HasSpawned(), 9999);

    DisableGameModeHud();

    while (true) {
        Boolean ResetRequestDone: IsTrueForAll(CustomHealthReseter.Tasks, !ArrayContains(ArrayElement(), EventPlayer()));
    
        CustomHealthReseter.SendHealthResetRequest(EventPlayer());
        Wait(0.016);
        WaitUntil(ResetRequestDone, 9999);

        # Exclude Dva from the Default Max Health Code
        if (IsDva) {
            WaitUntil(HeroChanged, 9999);
            continue;
        }

        # Limit Tank Health
        if (ArrayContains(AllTankHeroes(), EventPlayer().Hero())) {
            SetLimitedMaxHealth();
        }

        WaitUntil(HeroChanged, 9999);
    }
}

rule: 'Dva Setup' Event.OngoingPlayer Team.Team1 Player.Dva
{
    WaitUntil(IsInAlternateForm(EventPlayer()) == false, 9999);
    
    Boolean ResetRequestDone: IsTrueForAll(CustomHealthReseter.Tasks, !ArrayContains(ArrayElement(), EventPlayer()));
    WaitUntil(ResetRequestDone, 9999);
    
    SetLimitedMaxHealth();

    WaitUntil(IsInAlternateForm(EventPlayer()) == true, 9999);

    CustomHealthReseter.SendHealthResetRequest(EventPlayer()); 

    Loop();
}

rule: 'Player Joining' Event.OnPlayerJoin Team.Team1
{
    Scoreboard.CreateListing(EventPlayer());
}

rule: 'Load Global Hud Elements'
{
    TimerHud.CreateHUD();
    ObjectiveHud.CreateHUD();
}

rule: 'TimerHud Main Method'
{
    TimerHud.main();
}

rule: 'Update Scoreboard Player State'
{
    Scoreboard.StartUpdatingPlayerState();
}